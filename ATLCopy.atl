-- @atlcompiler atl2006
-- $Id$
-- Generated by: EModelCopyGenerator.atl 7412 2008-04-01 09:51:42Z dwagelaa
module ATLCopy;

create OUT : ATL from IN : ATL, SUPER : ATL;

helper def : inElements : Set(ATL!"ATL::LocatedElement") = 
	ATL!"ATL::LocatedElement".allInstancesFrom('IN');

rule Unit {
    from s : ATL!"ATL::Unit" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"ATL::Unit")
		else false endif)
    to t : ATL!"ATL::Unit" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries)
}

rule Library {
    from s : ATL!"ATL::Library" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Library" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        helpers <- s.helpers)
}

rule Query {
    from s : ATL!"ATL::Query" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Query" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        body <- s.body,
        helpers <- s.helpers)
}

rule Module {
    from s : ATL!"ATL::Module" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Module" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isRefining <- s.isRefining,
        libraries <- s.libraries,
        inModels <- s.inModels,
        outModels <- s.outModels,
        elements <- s.elements)
}

rule Helper {
    from s : ATL!"ATL::Helper" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Helper" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        definition <- s.definition)
}

rule MatchedRule {
    from s : ATL!"ATL::MatchedRule" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"ATL::MatchedRule")
		else false endif)
    to t : ATL!"ATL::MatchedRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule)
}

rule LazyMatchedRule {
    from s : ATL!"ATL::LazyMatchedRule" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::LazyMatchedRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        isUnique <- s.isUnique,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule)
}

rule CalledRule {
    from s : ATL!"ATL::CalledRule" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::CalledRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isEntrypoint <- s.isEntrypoint,
        isEndpoint <- s.isEndpoint,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        parameters <- s.parameters)
}

rule InPattern {
    from s : ATL!"ATL::InPattern" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::InPattern" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements,
        filter <- s.filter)
}

rule OutPattern {
    from s : ATL!"ATL::OutPattern" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::OutPattern" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements)
}

rule SimpleInPatternElement {
    from s : ATL!"ATL::SimpleInPatternElement" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::SimpleInPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        "mapsTo" <- s."mapsTo",
        models <- s.models)
}

rule SimpleOutPatternElement {
    from s : ATL!"ATL::SimpleOutPatternElement" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::SimpleOutPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model)
}

rule ForEachOutPatternElement {
    from s : ATL!"ATL::ForEachOutPatternElement" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ForEachOutPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model,
        collection <- s.collection,
        iterator <- s.iterator)
}

rule Binding {
    from s : ATL!"ATL::Binding" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Binding" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        value <- s.value)
}

rule RuleVariableDeclaration {
    from s : ATL!"ATL::RuleVariableDeclaration" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::RuleVariableDeclaration" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule LibraryRef {
    from s : ATL!"ATL::LibraryRef" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::LibraryRef" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name)
}

rule ActionBlock {
    from s : ATL!"ATL::ActionBlock" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ActionBlock" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        statements <- s.statements)
}

rule ExpressionStat {
    from s : ATL!"ATL::ExpressionStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ExpressionStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        expression <- s.expression)
}

rule BindingStat {
    from s : ATL!"ATL::BindingStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::BindingStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        source <- s.source,
        value <- s.value)
}

rule IfStat {
    from s : ATL!"ATL::IfStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::IfStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        condition <- s.condition,
        thenStatements <- s.thenStatements,
        elseStatements <- s.elseStatements)
}

rule ForStat {
    from s : ATL!"ATL::ForStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ForStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        iterator <- s.iterator,
        collection <- s.collection,
        statements <- s.statements)
}

rule VariableExp {
    from s : ATL!"OCL::VariableExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::VariableExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        referredVariable <- s.referredVariable)
}

rule SuperExp {
    from s : ATL!"OCL::SuperExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SuperExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule StringExp {
    from s : ATL!"OCL::StringExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::StringExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        stringSymbol <- s.stringSymbol,
        type <- s.type)
}

rule BooleanExp {
    from s : ATL!"OCL::BooleanExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BooleanExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        booleanSymbol <- s.booleanSymbol,
        type <- s.type)
}

rule RealExp {
    from s : ATL!"OCL::RealExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::RealExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        realSymbol <- s.realSymbol,
        type <- s.type)
}

rule IntegerExp {
    from s : ATL!"OCL::IntegerExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IntegerExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        integerSymbol <- s.integerSymbol,
        type <- s.type)
}

rule BagExp {
    from s : ATL!"OCL::BagExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BagExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule OrderedSetExp {
    from s : ATL!"OCL::OrderedSetExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OrderedSetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SequenceExp {
    from s : ATL!"OCL::SequenceExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SequenceExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SetExp {
    from s : ATL!"OCL::SetExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule TupleExp {
    from s : ATL!"OCL::TupleExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TupleExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        tuplePart <- s.tuplePart)
}

rule TuplePart {
    from s : ATL!"OCL::TuplePart" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TuplePart" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule MapExp {
    from s : ATL!"OCL::MapExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::MapExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule MapElement {
    from s : ATL!"OCL::MapElement" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::MapElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        key <- s.key,
        value <- s.value)
}

rule EnumLiteralExp {
    from s : ATL!"OCL::EnumLiteralExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::EnumLiteralExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclUndefinedExp {
    from s : ATL!"OCL::OclUndefinedExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclUndefinedExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule NavigationOrAttributeCallExp {
    from s : ATL!"OCL::NavigationOrAttributeCallExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::NavigationOrAttributeCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source)
}

rule OperationCallExp {
    from s : ATL!"OCL::OperationCallExp" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"OCL::OperationCallExp")
		else false endif)
    to t : ATL!"OCL::OperationCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule OperatorCallExp {
    from s : ATL!"OCL::OperatorCallExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OperatorCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule CollectionOperationCallExp {
    from s : ATL!"OCL::CollectionOperationCallExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::CollectionOperationCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule IterateExp {
    from s : ATL!"OCL::IterateExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IterateExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators,
        result <- s.result)
}

rule IteratorExp {
    from s : ATL!"OCL::IteratorExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IteratorExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators)
}

rule LetExp {
    from s : ATL!"OCL::LetExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::LetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        variable <- s.variable,
        in_ <- s.in_)
}

rule IfExp {
    from s : ATL!"OCL::IfExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IfExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        thenExpression <- s.thenExpression,
        condition <- s.condition,
        elseExpression <- s.elseExpression)
}

rule VariableDeclaration {
    from s : ATL!"OCL::VariableDeclaration" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"OCL::VariableDeclaration")
		else false endif)
    to t : ATL!"OCL::VariableDeclaration" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Iterator {
    from s : ATL!"OCL::Iterator" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Iterator" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Parameter {
    from s : ATL!"OCL::Parameter" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Parameter" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule StringType {
    from s : ATL!"OCL::StringType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::StringType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BooleanType {
    from s : ATL!"OCL::BooleanType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BooleanType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule IntegerType {
    from s : ATL!"OCL::IntegerType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IntegerType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule RealType {
    from s : ATL!"OCL::RealType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::RealType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BagType {
    from s : ATL!"OCL::BagType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BagType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OrderedSetType {
    from s : ATL!"OCL::OrderedSetType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OrderedSetType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SequenceType {
    from s : ATL!"OCL::SequenceType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SequenceType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SetType {
    from s : ATL!"OCL::SetType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SetType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OclAnyType {
    from s : ATL!"OCL::OclAnyType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclAnyType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule "TupleType" {
    from s : ATL!"OCL::TupleType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TupleType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        attributes <- s.attributes)
}

rule TupleTypeAttribute {
    from s : ATL!"OCL::TupleTypeAttribute" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TupleTypeAttribute" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclModelElement {
    from s : ATL!"OCL::OclModelElement" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclModelElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        model <- s.model)
}

rule MapType {
    from s : ATL!"OCL::MapType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::MapType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        valueType <- s.valueType,
        keyType <- s.keyType)
}

rule OclFeatureDefinition {
    from s : ATL!"OCL::OclFeatureDefinition" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclFeatureDefinition" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        feature <- s.feature,
        context_ <- s.context_)
}

rule OclContextDefinition {
    from s : ATL!"OCL::OclContextDefinition" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclContextDefinition" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        context_ <- s.context_)
}

rule Attribute {
    from s : ATL!"OCL::Attribute" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Attribute" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        initExpression <- s.initExpression,
        type <- s.type)
}

rule Operation {
    from s : ATL!"OCL::Operation" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Operation" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        parameters <- s.parameters,
        returnType <- s.returnType,
        body <- s.body)
}

rule OclModel {
    from s : ATL!"OCL::OclModel" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclModel" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        metamodel <- s.metamodel,
        elements <- s.elements,
        model <- s.model)
}

